{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "twemoji-area",
  "type": "registry:component",
  "title": "Twemoji Area",
  "description": "A component for processing and displaying emojis using Twemoji within a container",
  "dependencies": [
    "@twemoji/api",
    "react-error-boundary"
  ],
  "files": [
    {
      "path": "registry/new-york/twemoji-area/TwemojiArea.tsx",
      "type": "registry:component",
      "content": "import { ReactFC } from \"@/lib/utils\";\nimport { cn } from \"@/lib/utils\";\nimport { ErrorBoundary } from \"react-error-boundary\";\nimport twemoji from \"@twemoji/api\";\nimport {\n  useEffect,\n  useRef,\n  useState,\n  Children,\n  isValidElement,\n  cloneElement,\n  ReactNode,\n  Fragment,\n  ReactElement,\n  memo,\n  useMemo,\n} from \"react\";\n\nexport type Size = \"xs\" | \"sm\" | \"md\" | \"lg\" | \"xl\";\n\nconst sizeClasses = {\n  xs: \"text-xs\",\n  sm: \"text-sm\",\n  md: \"text-base\",\n  lg: \"text-lg\",\n  xl: \"text-xl\",\n} as const;\n\nexport type TwemojiAreaProps = {\n  children: ReactNode;\n  size?: Size;\n  className?: string;\n};\n\n// Helper function to process text nodes and replace emojis\nfunction processTextNode(text: string, size: Size = \"md\"): ReactNode[] {\n  // Skip empty or non-string inputs\n  if (!text || typeof text !== \"string\") {\n    return [text];\n  }\n\n  try {\n    const container = document.createElement(\"div\");\n    container.textContent = text;\n    twemoji.parse(container);\n\n    // Convert the container's HTML content back to React elements\n    const processed: ReactNode[] = [];\n    container.childNodes.forEach((node, index) => {\n      if (node.nodeType === Node.TEXT_NODE) {\n        processed.push(node.textContent);\n      } else if (\n        node.nodeType === Node.ELEMENT_NODE &&\n        node instanceof HTMLImageElement\n      ) {\n        processed.push(\n          <img\n            key={`emoji-${index}`}\n            src={node.src}\n            alt={node.alt}\n            className={cn(\"inline-block\", sizeClasses[size])}\n            style={{\n              height: \"1em\",\n              width: \"1em\",\n              margin: \"0 0.05em 0 0.1em\",\n              verticalAlign: \"-0.1em\",\n            }}\n          />\n        );\n      }\n    });\n\n    return processed;\n  } catch (error) {\n    console.warn(\"Failed to process emoji in text:\", error);\n    return [text]; // Return original text on error\n  }\n}\n\ninterface ReactElementWithChildren extends ReactElement {\n  props: {\n    children?: ReactNode;\n    [key: string]: any;\n  };\n}\n\n// Recursive function to process React nodes\nconst processNode = (node: ReactNode, size: Size): ReactNode => {\n  // Handle null or undefined\n  if (node == null) {\n    return node;\n  }\n\n  // Handle text nodes\n  if (typeof node === \"string\") {\n    return processTextNode(node, size);\n  }\n\n  // Handle arrays\n  if (Array.isArray(node)) {\n    return node.map((child, index) => (\n      <Fragment key={index}>{processNode(child, size)}</Fragment>\n    ));\n  }\n\n  // Handle React elements\n  if (isValidElement(node)) {\n    const element = node as ReactElementWithChildren;\n\n    // Skip processing for elements that might already handle emojis\n    if (\n      element.type === \"img\" ||\n      element.type === \"svg\" ||\n      element.type === \"canvas\"\n    ) {\n      return element;\n    }\n\n    const children = element.props.children\n      ? Children.map(element.props.children, (child) =>\n          processNode(child, size)\n        )\n      : element.props.children;\n\n    return cloneElement(element, {\n      ...element.props,\n      children,\n    });\n  }\n\n  // Return as is for other types\n  return node;\n};\n\nexport const TwemojiArea = memo(\n  ({ children, size = \"md\", className }: TwemojiAreaProps) => {\n    const [isMounted, setIsMounted] = useState(false);\n\n    useEffect(() => {\n      setIsMounted(true);\n      return () => setIsMounted(false);\n    }, []);\n\n    // If not yet mounted, render children without processing to avoid hydration issues\n    if (!isMounted) {\n      return <div className={className}>{children}</div>;\n    }\n\n    // Memoize processed children to avoid unnecessary re-processing\n    const processedChildren = useMemo(() => {\n      return processNode(children, size);\n    }, [children, size]);\n\n    return (\n      <ErrorBoundary\n        fallback={<div className={className}>{children}</div>}\n        onError={(error: Error) => {\n          console.warn(\"TwemojiArea failed to render:\", error);\n        }}\n      >\n        <div className={className}>{processedChildren}</div>\n      </ErrorBoundary>\n    );\n  }\n);\n"
    }
  ]
}