{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "dialog-manager",
  "type": "registry:component",
  "title": "Dialog Manager",
  "description": "A context-based dialog management system that allows for opening, closing, and managing multiple dialogs in your React application.",
  "registryDependencies": [
    "https://ui.kitze.io/r/responsive-dialog.json"
  ],
  "files": [
    {
      "path": "registry/new-york/dialog-manager/DialogManager.tsx",
      "type": "registry:component",
      "content": "import React, {\n  createContext,\n  useCallback,\n  useContext,\n  useMemo,\n  useState,\n  memo,\n} from \"react\";\nimport {\n  ResponsiveDialog,\n  ResponsiveDialogProps,\n} from \"@/registry/new-york/responsive-dialog/ResponsiveDialog\";\n\nexport type OpenDialogProps = {\n  title?: string;\n  component:\n    | ((props: { close: () => void }) => React.ReactNode)\n    | React.ComponentType<any>;\n  props?: Record<string, any>;\n  size?: ResponsiveDialogProps[\"size\"];\n  classNames?: ResponsiveDialogProps[\"classNames\"];\n};\n\ntype DialogConfig = OpenDialogProps & {\n  id: string;\n};\n\ntype DialogContextType = {\n  openDialog: (config: OpenDialogProps) => string;\n  closeDialog: (id: string) => void;\n  closeAllDialogs: () => void;\n};\n\nconst DialogContext = createContext<DialogContextType | null>(null);\n\nexport const useDialog = () => {\n  const context = useContext(DialogContext);\n  if (!context) {\n    throw new Error(\"useDialog must be used within a DialogProvider\");\n  }\n  return context;\n};\n\nexport type DialogManagerProps = {\n  classNames?: {\n    root?: string;\n  };\n  children?: React.ReactNode;\n};\n\nconst DialogList = memo(function DialogList({\n  dialogs,\n  onClose,\n}: {\n  dialogs: DialogConfig[];\n  onClose: (id: string) => void;\n}) {\n  return (\n    <>\n      {dialogs.map(\n        ({ id, title, component: Component, props, size, classNames }) => (\n          <div key={id} className=\"pointer-events-auto\">\n            <ResponsiveDialog\n              title={title}\n              showCancel={true}\n              onCancel={() => onClose(id)}\n              open={true}\n              onOpenChange={(open) => {\n                if (!open) onClose(id);\n              }}\n              size={size}\n              classNames={classNames}\n            >\n              {typeof Component === \"function\" ? (\n                <Component {...props} close={() => onClose(id)} />\n              ) : (\n                // @ts-ignore\n                <Component {...props} />\n              )}\n            </ResponsiveDialog>\n          </div>\n        )\n      )}\n    </>\n  );\n});\n\nexport const DialogManager = memo(function DialogManager({\n  classNames,\n  children,\n}: DialogManagerProps) {\n  const [dialogs, setDialogs] = useState<DialogConfig[]>([]);\n\n  const openDialog = useCallback((config: OpenDialogProps) => {\n    const id = Math.random().toString(36).substring(7);\n    setDialogs((prev) => {\n      const newDialogs = [...prev, { ...config, id }];\n      return newDialogs;\n    });\n    return id;\n  }, []);\n\n  const closeDialog = useCallback((id: string) => {\n    setDialogs((prev) => prev.filter((dialog) => dialog.id !== id));\n  }, []);\n\n  const closeAllDialogs = useCallback(() => {\n    setDialogs([]);\n  }, []);\n\n  const contextValue = useMemo(\n    () => ({\n      openDialog,\n      closeDialog,\n      closeAllDialogs,\n    }),\n    [openDialog, closeDialog, closeAllDialogs]\n  );\n\n  return (\n    <DialogContext.Provider value={contextValue}>\n      {children}\n      <DialogList dialogs={dialogs} onClose={closeDialog} />\n    </DialogContext.Provider>\n  );\n});\n"
    }
  ]
}