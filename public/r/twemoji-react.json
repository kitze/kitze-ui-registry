{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "twemoji-react",
  "type": "registry:component",
  "title": "Twemoji React",
  "description": "A React component for displaying Twitter Emoji (Twemoji) in your React application",
  "dependencies": [
    "@twemoji/api",
    "lodash.isequal"
  ],
  "files": [
    {
      "path": "registry/new-york/twemoji-react/TwemojiReact.tsx",
      "type": "registry:component",
      "content": "import {\n  useEffect,\n  useRef,\n  Children,\n  cloneElement,\n  createElement,\n  ReactNode,\n  memo,\n  useMemo,\n  useCallback,\n} from \"react\";\nimport twemoji from \"@twemoji/api\";\nimport isEqual from \"lodash.isequal\";\n\nexport interface TwemojiReactProps {\n  children?: ReactNode;\n  noWrapper?: boolean;\n  options?: object;\n  tag?: string;\n}\n\nexport const TwemojiReact = memo(\n  ({\n    children,\n    noWrapper = false,\n    options = {},\n    tag = \"div\",\n    ...other\n  }: TwemojiReactProps) => {\n    const rootRef = useRef<HTMLElement>(null);\n    const childrenRefs = useRef<{ [key: string]: any }>({});\n    const prevPropsRef = useRef<TwemojiReactProps | null>(null);\n\n    // Memoize current props to avoid unnecessary re-renders\n    const currentProps = useMemo(\n      () => ({\n        children,\n        noWrapper,\n        options,\n        tag,\n      }),\n      [children, noWrapper, options, tag]\n    );\n\n    // Memoize parse function to avoid recreating it on each render\n    const parseTwemoji = useCallback(() => {\n      try {\n        if (noWrapper) {\n          Object.values(childrenRefs.current).forEach((ref) => {\n            if (ref.current) {\n              twemoji.parse(ref.current, options);\n            }\n          });\n        } else if (rootRef.current) {\n          twemoji.parse(rootRef.current, options);\n        }\n      } catch (error) {\n        console.warn(\"Failed to parse twemoji:\", error);\n      }\n    }, [noWrapper, options]);\n\n    useEffect(() => {\n      // Only parse if props have changed\n      if (!isEqual(currentProps, prevPropsRef.current)) {\n        parseTwemoji();\n        prevPropsRef.current = currentProps;\n      }\n    }, [currentProps, parseTwemoji]);\n\n    if (noWrapper) {\n      return (\n        <>\n          {Children.map(children, (child, index) => {\n            if (typeof child === \"string\") {\n              // Create a span for string children when using noWrapper\n              return (\n                <span\n                  ref={(el) => {\n                    if (!childrenRefs.current[index]) {\n                      childrenRefs.current[index] = { current: null };\n                    }\n                    childrenRefs.current[index].current = el;\n                  }}\n                  dangerouslySetInnerHTML={{ __html: child }}\n                />\n              );\n            }\n\n            if (!childrenRefs.current[index]) {\n              childrenRefs.current[index] = { current: null };\n            }\n\n            return cloneElement(child as any, {\n              ref: (el: any) => {\n                childrenRefs.current[index].current = el;\n\n                // Call the original ref if it exists\n                const originalRef = (child as any).ref;\n                if (originalRef) {\n                  if (typeof originalRef === \"function\") {\n                    originalRef(el);\n                  } else if (originalRef.hasOwnProperty(\"current\")) {\n                    originalRef.current = el;\n                  }\n                }\n              },\n            });\n          })}\n        </>\n      );\n    }\n\n    const elementProps = { ...other, ref: rootRef };\n    delete (elementProps as any).options;\n    return createElement(tag, elementProps, children);\n  }\n);\n"
    }
  ]
}